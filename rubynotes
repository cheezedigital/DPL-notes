Ruby Notes

===================
Basic Rules
===================
Variables must start with a letter no numbers or special characters
no spaces can only use _ underscores
------------------------------
Example:
justin_cookies == correct =D
#apples and oranges == wrong
------------------------------

Puts "name" - cout/print/ displays "name"

auto declaration = good but also bad imo



===================
Basic Commands
===================
.class - returns data type
puts "name" - cout/print/ displays "name"
gets - takes an input from the user + end line /caridge return
gets.chomp - removes endline/caridge return

------------------------------
Example:
puts "how old are you?"
age = gets
puts age
age.class = string
------------------------------




------------------
Chaining commands
------------------------------------
"justin".reverse.upcase = "NITSUJ"
"NITSUJ".reverse.downcase = "justin"
---------------------------------------
===================
String Commands
===================
.upcase - changes all string letters to uppercase
.downcase - changes all to string letters to lowercase
.reverse - reverses order of string
.capitalize - capitalizes first word/letter

there are four variables

local_variable = "hello"

@instance_variable = "justin"

@@class_variable = "human"

$glabal_variable = "DO NOT USE"

Ruby -

Numbers & String : Ruby’s math and text objects
Methods : Methods like .reverse and symbolic methods like * are method actions
DataTypes : Time, :symbol, Date, Array, Strings, Fixnum, float, Hash

to_s : converts things to strings
to_i : converts things to integers (numbers)
to_a : converts things to arrays
:simple word - when you put a simple word in front of a colon you get a symbol. symbols are cheaper then strings
nil : means there is nothing there.

\ : escape character. or use single quotes inside double quotes.
	EX : ‘ don \’ t do this’
easier to just use double quotes then you can use a single quote inside without issues
	EX : “don’t do this”

#{ } : string interpolation. use variable instead of concatenation. (preference though) any valid ruby code can go inside.
	EX : “1 + 1 =  #{1+1}”

prints out “1 + 1 =  2”

name = “Lia”
	EX : “Hello, “ + name + “ . How are you?”
	EX : “Hello, #{name}. How are you?”   <—- string interpolate

IMPORTANT : But using string interpolation you must use double quotes. single quotes will print out \#{name}

\n : new line character. manually putting something on the next line.
	EX : “Hello\nLia”
will print out :
	Hello
	Lia

IMPORTANT : this also must be used with double quotes not single. single quotes will print out “Hello\nLia”

[ ] : empty array.
[“Jeremy”, “Will”, “Ty”] : this is considered a string array. each string is an index

you can even assign this array to a variable.
	EX : people = [“Jeremy”, “Will”, “Ty”]

puts storage[0] <— this prints out index 0
	=>Jeremy

IMPORTANT : array indexes always start with a 0. this is called 0 based indexing

.count : counts how many elements are in something.
	Ex : people

prints out 3

.length, .count, and .size are all the same

< < : shovel operator. this puts things into an array
	EX : people << “Soldier”

now soldier will be put at the end of the storage array
	EX : people = [“Jeremy”, “Will”, “Ty”, “Soldier”]

you can combine more << to add multiple items
	EX : people << “Soldier” << “Lia” << “and so on”


.each : is an array method

people.each do |person|    <—person can be named any variable name
	puts person                        but is a local variable. cannot be used outside of this block
end

this will print out each person in the people array

block : a block starts with a do and end with end

multidimensional array : is an array inside of an array
	EX : things = [ [1,2.3], [4,5,6],  [ 9, 8,7] ]

to get something from the multidimensional array :
	puts things[0][1]

this will print out 2


Variables

variable rules

#1. all names should be lowercase
#2. begins with a letter
#3. separate words with an _ (underscore)

In Ruby anything can be assigned to a variable
EX : people = [“Jeremy”, “Will”, “Ty”]

Ruby has four types of variables:

local_variable = “hello” : can_be_anything = “hello”

@instance_variable = “Lia” : @

@@class_variable = “Human” : @@

$global_variable = “DO NOT USE” : $

Scope : local variables are only available locally. cannot got out of the local scope
	EX : [ [ [ [ [local] instance] class] ] global]


{ } : a hash also used for a collection of things. can use double or single quotes.
	EX : storage = {“Box 1” => “Stuff”, “Box 2” => “More Stuff”}

and like an array can have a hash inside a hash.
	EX : storage = {“Box 1” => “Stuff”, “Box 2” => “More Stuff”, “Box 3 => [“box”, “of”, “stuff” ] }

puts storage[“Box 1”]
	>”Stuff”

IMPORTANT : does not use 0 based index. its is a key based index. Uses Keys and Values.

IMPORTANT : in a hash you must reference the key exactly how its been written. keys can be anything. but each key also has to be unique. keys are case sensitive

storage.each_pair do | key, value |
	puts “The key is #{key} and the value is #{value}”
end

	>The key is Box 1 and the value is Stuff
	>The key is Box 2 and the value is More Stuff
	>The key is Box 3 and the value is [box, of, stuff]

 :name : a data type of symbol, just like array, string are data types… used where you might use a string. used mostly in hashes. a symbol might be used for the key instead. convention in a symbol is all lowercase.

	EX : me = {:name => “Lia”, :age => 26}
		puts me[:name]
		>”Lia”

to set a value and add to the hash you cannot use << like in an array. must manually set.
	EX : me[:sex] = “female”

IMPORTANT : can’t have  -  (dashes) in variables  and hashes


When to use a Hash vs Array

Array : use an array when you have a generic collection of things you want to do something to everything.
	EX : dog = [1, “happy”, 8, “no”, “lab”]

Hash :  when you want each object in your collection to have a specific name
	EX : dog = [
		   {:breed => ‘lab’, :name => ‘happy’, :command => ’no’},
		   {:breed => ‘mutt’, :name => ’sad’, :command => ’yes’}
		]

Time data type :

somethings you can do :

	Time.now
	Time.now.year
	Time.now.hour
	Time.now.min

current_year = Time.now.year

	puts current_year

>2014

conditional statements =
true
false
nil

if my_age > 20
 puts "Gonna drink some this weekend!"
end

loops

while loop

nemo_is_still_lost = true
puts "oh no! Nemo is lost"
while nemo_is_still_lost
 puts "just keep swiming"
 puts "did you find nemo?"
 answer = gets.chomp
 if answer =='yes'
  nemo_is_still_lost = false
 end
end

variable assignment value

Datatypes = time, symbol, date, array, strings, fixum, floats, hash

examples of using hash would be

array
dog_names = [“max”, “althea”]

hash
aniamls = {“max” => “dog”, “fluffy” => “cat”}

the purpose of using either

dog_names = [“max”, “fido”]

dog = {:name => “max”, :breed => “poodle”, :age  => 3}

dog2 = {:name => “fido”, :breed => “chihuanhua”, :age => 6}

dogs = [dog, dog2]

sudo code = basically write our thought process for solving a problem. not actually writing code.

I need to write a program that cooks breakfast.

grab_frying_pan
grab_utencils
grab_ingredients (“eggs”, “bacon”, “toast”)

thing_being_cooked =
place_ingredients_into_pan (“bacon”)

if ingredient_being_is_cooked
	remove_ingredient_from_pan
	place_ingredient_on_plate





serve_food

*note: need to know what i’m cooking


conditionals in ruby =
if some_condition
  do_stuff
end
conditions are looking for either yes, or no.

if burgers_are_done
   take_them_off_the_grill
end

to understand this fully, we need to introduce some new datatypes

Boolean = is when we are referencing either yes or no, however, for boolean we use true and false.
if burgers are done  true or false

true
false

if nil
if something is nil = something is nothing
false and nil are the only 2 things in ruby that equate to being false. if it isn’t false, or nil, then it’s true.

if your age is greater than or equal to
if my_age >= 21
 puts “gonna drink some beer this weekend”
end

comparison operators
> greater than
< less
>= greater than or equal
<= less than or equal
== both sides are the same
!=

conditional operators
&&
||


if x_in_space_1 && x_in_space_2 && x_in_space_3
 puts “x wins!”
end

if x in space and x in space and x in space

if you_drive_a_truck || you_drive_a_car
 puts “can I get a ride?”
end

8 possible solutions for tic tac toe

if x_in_top_left && x_in_top_mid && x_in_top_right ||
  x_in_mid_left && x_in_mid_mid && x_in_mid_right ||
 x_in_bot_left && x_in_bot_mid && x_in_bot_right
 puts “x wins!”
end

if we’re doing if statements we need a fall back plan. what happens if our plan keeps returning false.

if your_age > 20
  puts “come drink beer with me”
else
 puts “you can come, too, but gotta drink kook-aid”
end

unless your_car_is_working
 puts “hit me up, and I’ll give you a lift”
end

if your_age == my_age
  puts “we’re the same age!”
end

what if I wanted to say not equal. if your age is not e

if your_age != my_age
  puts “we’re different ages”
end
! = bang


unless you_already_ate
puts “let’s grab lunch”
end

puts “lets grab lunch” unless you_already_ate

puts “welcome, user” if user_signs_in

what if we have numerous conditions.

if your grade on the test is 90-100, otherwise, if your grade is 80-90, otherwise your grade is 70-80 otherwise your grade is 60-70 otherwise you fail

if your_grade > 90
 puts “You get an A”
elsif your_grade >= 80 && your_grade < 90
 puts “you get a B”
elsif your_grade >= 70 && your_grade <80
 puts “you get a c”
elsie your_grade >=60 && your_grade <70
 puts “you need to study more”
else
puts “you fail”
end



grade = ‘A’

case grade
when ‘A’
   puts “Yay! ice cream for you”
when ‘B’
  puts “not too shabby”
when ‘C’
 puts “might want to put some time into that”
when ‘D’
 puts “not doing too well”
when ‘F’
 puts “ok, you failed”
else
puts “not sure how you managed to get a #{grade}”
end

this comes in handy when something will or when something will be that

case doomsday
when ‘zombie apocalypse’
 puts “yikes”
when ‘zombie jesus’
when ‘earthquake’
end

a = “A”
b = “B”
grade = “A”

case grade
when a
   puts “you got A”
when b
   puts “you got a B”
end



RUBY NOTES
a method changes the oject it's called from so the string data type is altered.

case day
when "monday"
  puts "monday blues"
when "tuesday"
  puts "hello there"
when "wednesday"
  puts "hump day"
when "thursday"
  puts "thirsty thursday"
when "friday"
  puts "yay!"
else
  puts "it's the weekend bitches!"
end

sun_is_up = true

while sun_is_up
  puts "do stuff"
  is Time.now.hour > 7
    sun_is_up = false
  end
end

"hello".reverse
"hello".length
"hello".upcase

puts "hello"

a method is basically a way to name a set of instrucitons.

puts is also a method.

writing a method

when creating our own methods we create  def

def method_name

end

def does_x_win

end

def does_o_win

end
def is short for define. defining a method
def grab_food
  puts "grabbing some food"
  puts "and it's good!"
end

#turnary operator
x = 4
y = 5
x < y ? "YEAH!" : "nope"
"YEAH!"
----------------------------------------
#the whole purpose of having classes is because classes allow us to put down
# our thoughts, and turn them into code. classes allow us to name things. things
#we want to call on. when things have a name they're easier to call on.
#it allows us to be more specific. container that has a label on it.

#denpendices -----
#how do we make our own files?
#ruby has a loadpath, and the loadpath is an array of strings, and each one of the strings is
#a path to where the files are located
